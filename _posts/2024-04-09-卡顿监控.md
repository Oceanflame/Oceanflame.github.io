---
title: "APM - 卡顿监控及优化 - (二)卡顿监控"
date: 2024-04-09 00:00:00 +0800
categories: [APM, 卡顿监控及优化]
tags: [APM, 卡顿, 性能优化, iOS]
---
## 前言

&emsp;&emsp; 卡顿监控主要涉及以下几个内容：
1. 卡顿指标定义
2. 卡顿指标监控和获取
3. 各个指标获取方法原理

## 卡顿指标定义

### 分位帧率

分位：统计学概念，是将数据集分成相等的连续部分的值。分位值是数据集的临界值，它们将整个数据集分割成具有相同数量数据点的几个部分。

人话就是，100个数从大到小排列，90分位值就是第90个数。

分位统计有很多好处，比较突出的点就是**抗异常值**，便于获取全部数据后了解**数据分布**，同时便于设置阈值，用作性能指标。

依据上传的帧率集合做数据集，取相应分位用作指标计算，一点点递增优化

### 卡顿率

卡顿率 = 卡顿次数 / 启动次数

卡顿率的计算首先要定义好什么情况算一次卡顿，一次主线程阻塞算一次卡顿，但是阻塞多少秒算是卡顿呢？

这需要根据应用场景，实际体验，业务经验等来判断。就像一般人们认为延迟高于400ms，人们会感觉音视频通讯的延迟比较明显，所以定义，低于400ms延迟的才是符合标准的实时音视频通讯。体验上滑动列表页面0.5秒就能感受到卡顿，Matrix卡顿监控的默认值是2秒，也就是说阻塞两秒以上才算卡顿。或许2秒大家觉得很长，但是其实把卡顿标准定的过低也存在坏处，很容易导致收集上来的堆栈过多，难以聚类，从而不容易发现主要问题所在。

所以实际卡顿的标准，要视实际情况而定。

## 监控相关原理

以上两种指标是卡顿相关的常见指标，接下来介绍两种指标相关的监控原理和方案。

### 帧率监控原理

在卡顿原理里简单的提到了Vsync这信号，帧率监控本身也是根据这个原理来计算。

#### CADisplayLink

CADisplayLink是一个计时器对象，这个定时器在每次屏幕刷新时都会接收到一个回调，收到这个回调后，可以用于计算每一帧需要的时间
```swift
// CADisplayLink的属性和方法：

// target:接收回调的对象，selector:被调用的方法
let displayLink = CADisplayLink(targrt: self, selctor:#selector(update))
/* 
    add方法：选择将定时器添加到哪个线程的runloop
    to: 选择哪个线程的runloop（如果没有UI操作，可以放到单独线程上）
    forMode: runloop模式  .default: 在用户交互行为发生时不跟踪
                         .common: 绝大多数情况都会触发，用户交互也不会中断，适合连续动画更新场景
                         .tracking: 仅在用户发生交互行为时跟踪
    remove方法：将其从某一runloop移除
*/
displayLink.add(to: .main, forMode: .common)
displayLink.remove(to: .main, forMode: .common)
// 可以用于暂停和恢复
displayLink.isPause = true 
// 两次屏幕刷新的间隔时间，通常是固定的，60帧为16.67ms
displayLink.duration 
// 本次回调被触发的具体时间戳
displayLink.timestamp
// 预计下一次屏幕刷新会发生的时间
displayLink.targetTimestamp
// 移除并释放定时器资源
displayLink.invalidate()

// 一个可设置属性,系统会根据这个值来确定每秒回调触发次数，如果作为帧率监控，不建议设置此值，会影响准确性
displayLink.preferredFrameRateRange
```
通常我们只需要用到timestamp就可以计算出一秒的平均帧率，在实际计算具体的数据和上报方案时需要自行设计。

#### 帧间隔抖动

这是一种比较极致的卡顿概念。正常来说，60帧的手机一帧的展示时间为16.67ms，这个时长就是帧间隔。如果帧间隔波动幅度较大，每一帧的时间不一致且较为频繁，一样会让用户感觉到动画不流畅，所以在这种情况也是需要进行监控和优化的，当然通过上述的CADisplayLink可以做到。一般这种情况在flutter和web中会比较常见，需要频繁的进行build操作，也就是每个帧都会进行部分或者全部页面的重新绘制。

### 卡顿监控原理

卡顿监控相关主要针对主线程监控，因为UI相关更新都是主线程在做，一旦主线程被阻塞，UI更新和用户响应交互等操作必然会被阻塞，所以产生一个思路，我们需要定时判断主线程此时是否可以响应，如果某一时刻发现它不能响应，则说明它此时发生了卡顿。

#### 如何监控主线程？

> 这需要了解iOS的线程运行机制和Runloop
>
> 常规的线程只执行一次任务，执行完后线程就会退出，runloop就是iOS用来让线程持续存活，随时处理事件而不退出的机制，监控主线程，其实就是监控主线程的runloop是否正常响应

#### Runloop运行机制和卡顿监控机制

RunLoop处理任务的流程简化版（详细可以参考《[深入理解RunLoop](https://blog.ibireme.com/2015/05/18/runloop/)》）

![RunLoop简易流程](/assets/data/RunLoop简易流程.png)

RunLoop内存在多个mode，每个mode内存在一个观察者数组，观察者对象是用来观察Runloop对象正在做什么，然后通知外面的对象当前Runloop的状态

![RunLoop+Observer](/assets/data/RunLoop+Observer.png)

Matrix的方案是通过在主线程RunLoop启动和退出的添加回调，获取主线程完成这个任务的开始和结束状态。同时起一个子线程，定时检查主线程状态，主线程的状态超过一定阈值，证明主线程一直在忙，由于主线程负责渲染UI，主线程超过了他原本的响应时间，则说明它一定出现了卡顿。

#### 监控主线程的其他方式

监控Runloop相比于直接向主线程发信号来确认它有没有阻塞，监控Runloop就显得复杂了一点，所以其他方式就是定时向主线程发信号，如果主线程没有回应，就说明此时主线城阻塞了。这种方式存在一定的缺点，因为不停的要向主线程发信号，所以它会产生一定的性能损耗，所以这种方式进行卡顿监控的话，建议采用抽样的方式进行监控。

## 参考文章

[深入理解RunLoop](https://blog.ibireme.com/2015/05/18/runloop/)

[iOS中的3种卡顿检测](https://blog.csdn.net/u014600626/article/details/122524652)
